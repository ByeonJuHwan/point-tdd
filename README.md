# 포인트 사용 저장

### 요구사항

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다. (동시성)

### 단일 인스턴스에서의 동시성 이슈 해결방법

기본적으로 많이 알려진 동시성 이슈 처리 방법에는 비관적 락, 낙관적 락, 분산 락이 대표적입니다.
이 세 가지 동시성 처리 방법은 주로 멀티 인스턴스 환경에서 사용됩니다.

그렇다면 단일 인스턴스에서는 위 세 가지 처리 기법 말고 어떤 동시성 처리 방법을 사용할 수 있을까요?
대부분 아래와 같은 두 가지 방법을 많이 떠올리실 것입니다. 이 두 가지 방법으로 단일 인스턴스에서의 
동시성 처리(예: 포인트 저장/사용)를 진행해 보았습니다.

#### 1. `@Synchronized`

가장 간단하게 구현할 수 있는 방법은 `@Synchronized` 어노테이션을 사용하는 것입니다.
`@Synchronized`를 메서드에 적용하면, 해당 메서드 전체가 동기화 상태가 됩니다.

즉, 해당 메서드에 대해서는 단 한 개의 스레드만 접근이 가능하고 다른 스레드들은 대기하게 됩니다.
이 방식은 코드를 간결하게 유지하면서도 동시성 문제를 효과적으로 다룰 수 있게 해줍니다.

하지만 다른 스레드들이 대기는 하고 있지만 기존에 작업 중이던 스레드의 작업이 끝난다고 해서 대기 중인 작업이
반드시 순서대로 실행되지는 않습니다.

정리하자면 `@Synchronized`는 동시성에 대한 처리는 가능하지만 순서 보장이 되지 않습니다. 
따라서 순서 보장이 반드시 필요한 작업이라면 다른 방법을 고려해 봐야합니다.

#### 2. `ReentrantLock` 

앞서 살펴본 `@Synchronized`의 경우 동시성 이슈는 처리가 가능하지만 순서 보장이 되지 않았습니다.

이때 사용할 수 있는 방법으로 `ReentrantLock`이 있습니다.

`ReentrantLock`의 경우 명시적으로 lock(), unlock() 메서드를 통해서 동시성에 대한 처리가 가능하며,
공정 모드를 통해서 순서 보장이 가능합니다.

```kotlin
fun getLock(key: Long): ReentrantLock = lockMap.computeIfAbsent(key) { ReentrantLock(true) }
```

위 코드를 보면 락을 획득하는 시점에 공정 모드를 true로 설정합니다. 공정 모드를 설정하는 코틀린 코드를
한 단계 더 들어가서 살펴보면 true, false에 따라 순서 보장을 할 것인지 아닌지가 결정됩니다.

![](https://velog.velcdn.com/images/asdcz11/post/5aa20c9e-7ec4-4383-8c17-884852aaafee/image.png)

정리하자면 동시성 이슈를 해결함과 동시에 순서 보장이 필요한 로직이라면 ReentrantLock을 고려해 볼 수 있습니다.
다만, lock()과 unlock() 메서드를 반드시 쌍으로 사용해야 데드락과 같은 문제를 방지할 수 있습니다.
일반적으로 try-finally 블록을 사용하여 안전하게 락을 해제합니다.